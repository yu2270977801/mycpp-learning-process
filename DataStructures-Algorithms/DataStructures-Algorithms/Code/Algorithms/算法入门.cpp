//////基本算法思想
//分治法（经典的分治思想的算法是折半查找（二分查找）算法））
/*
* 二分查找每次都将原数组分为左右两个子序列，如果关键字比中间元素大，就继续到右边子序列查找，若小于中间元素就到左边子序列查找
*/
/*****************************二分查找算法*****************************************/
template <typename DataType> int binSearch(DataType* a, int n, DataType key)
{
	int low = 0, high = n - 1, mid; //设置低高游标和中间游标

	while (low <= high) //当 low 与 high 两个指针指向同一个元素时，查找结束
	{
		mid = (low + high) / 2; //确定中间点，将数组二分
		if (a[mid] == key) //如果中间元素是所查元素则返回
		{
			return mid;
		}
		if (key > a[mid]) //修改低位指针，在右边的子序列查找元素
			low = mid + 1;
		else
			high = mid - 1; //否则修改高位指针，在左边子序列查找元素
	}
	return -1;
}

//递归式―――就是指一种直接或者间接地调用原算法本身的一种算法
template <typename DataType> DataType factorial(DataType n)
{
	if (n == 0)
		return 1;
	return n * factorial(n - 1)
}

//回溯法―――八皇后问题例子
/*
* 将包含所有解的解空间看成一个树形的解空间，从根结点出发深度优先遍历所有的解，当探索到
*某个结点时，就判断是否包含问题的解，如果包含就继续沿着这条路线搜索下去，如果不
*包含，就说明该结点为根的子树一定不包含问题的最终解，跳过该子树逐层向其祖先结点回溯
*/

//穷举法
/*
* 在解空间中穷举出所有可能的解，再对每一个可能的解进行判断，得出最合适的答案。
*/

//随机算法
/*
* 随机算法就是指算法本身包含有随机数生成器或者说能使输入随机化的算法
*/

//案例
/**********************************************************************************/
/*简单折半查找*/
/**********************************************************************************/
#include <iostream> 
#include <stdlib.h> 
#include <time.h> 
using namespace std;
#define MAX 101 
/***********************************************************************************/
/*输入函数*/
/***********************************************************************************/
void input(int num[])
{
	int i;
	srand((unsigned)time(NULL)); //设置随机种子
	for (i = 1; i < MAX; i++) //生成随机数
		num[i] = rand() % 100;
}
/**********************************************************************************/
/* 输出函数*/
/**********************************************************************************/
void output(int num[])
{
	int i;
	for (i = 1; i < MAX; i++)
	{
		cout << num[i] << " ";
		if (0 == i % 10)
			cout << endl;
	}
}
/*********************************************************************************/
/* 快速排序*/
/**********************************************************************************/
void sort(int num[], int low, int high) /* quick sort */
{
	int l, h;
	if (low < high)
	{
		l = low;
		h = high;
		num[0] = num[l]; /* save pivot */
		while (l < h)
		{
			while (l < h && num[h] >= num[0]) h--; //利用快速排序使数据有序
			num[l] = num[h];
			while (l < h && num[l] <= num[0]) l++;
			num[h] = num[l];
		}
		num[l] = num[0]; /* insert pivot */
		sort(num, low, l - 1);
		sort(num, l + 1, high);
	}
}
/**********************************************************************************/
/*折半查找函数*/
/**********************************************************************************/
int find(int num[], int x, int low, int high)
{
	int mid; //中间位置
	while (low <= high)
	{
		mid = (low + high) / 2; /* 找到 */
		if (x == num[mid])
			return mid;
		else if (x < num[mid]) //两边的游标不停往中间移动比较
			high = mid - 1;
		else
			low = mid + 1;
	}
	return 0;
}
/**********************************************************************************/
/*主函数*/
/**********************************************************************************/
int main()
{
	int x, pos, num[MAX];
	input(num);
	cout << "排序前:" << endl;
	output(num);
	sort(num, 1, MAX - 1);
	cout << "排序后：" << endl;
	output(num);
	cout << "请输入要查找的数：" << endl;
	cin >> x;
	pos = find(num, x, 1, MAX - 1); //调用查找函数
	if (pos)
		cout << "OK!" << x << "is found in pos: " << pos << endl;
	else
		cout << "OK!" << x << "is found in pos: " << endl;
	return 0;
}

//设计程序对随机生成的数字进行排序―――（采用一种最基本的排序算法――冒泡排序和快速排序算法）
//方法一：
/*冒泡排序*/
/**********************************************************************************/
#include <iostream> 
#include <stdlib.h> 
#include <time.h> 
using namespace std;
#define MAX 11 
/**********************************************************************************/
/*输入函数*/
/*********************************************************************************/
void input(int num[])
{
	int i;

	srand((unsigned)time(NULL)); //设置随机种子
	for (i = 1; i < MAX; i++)
		num[i] = rand() % 100; //生成随机函数
}
/**********************************************************************************/
/*输出函数*/
/**********************************************************************************/
void output(int num[])
{
	int i;

	for (i = 1; i < MAX; i++)
	{
		cout << num[i] << " ";
		if (0 == i % 10)
			cout << endl;
	}
	cout << endl;
}****
/**********************************************************************************/
/*冒泡排序*/
/***********************************************************************************/
void sort(int num[])
{
	int i, j, tmp;
	for (i = 1; i < MAX - 1; i++)
	{

		for (j = 1; j < MAX - i; j++)
		{

			if (num[j] > num[j + 1])
			{
				tmp = num[j];
				num[j] = num[j + 1];
				num[j + 1] = tmp;
			}
		}
	}
}
/**********************************************************************************/
/*主函数*/
/**********************************************************************************/
int main()
{
	int num[MAX];
	cout << "冒泡排序前：" << endl;
	input(num);
	output(num);
	sort(num);
	cout << "冒泡排序后：" << endl;
	output(num);
	return 0;
}
//方法二：
/* 双向冒泡*/
/*********************************************************************************/
#include <iostream> 
#include <stdlib.h> 
#include <time.h> 
using namespace std;
#define swap(x, y){int tmp; tmp=x; x=y; y=tmp;} 
#define MAX 11 
/********************************************************************************/
/* 输入函数*/
/********************************************************************************/
void input(int num[])
{
	int i;

	srand((unsigned)time(NULL)); //设置随机种子
	for (i = 1; i < MAX; i++)
		num[i] = rand() % 100; //生成随机函数
}
/*********************************************************************************/
/*输出函数*/
/*********************************************************************************/
void output(int num[])
{
	int i;

	for (i = 1; i < MAX; i++)
	{
		cout << num[i] << " ";
		if (0 == i % 10)
			cout << endl;
	}
	cout << endl;
}
/**********************************************************************************/
/*双向冒泡算法*/
/**********************************************************************************/
void sort(int num[], int low, int high)
{
	int i;
	while (low < high)
	{
		for (i = low; i < high; i++) //向高位冒泡
			if (num[i] > num[i + 1])
				swap(num[i], num[i + 1]);
		high--;
		for (i = high; i > low; i--) //向低位排序
			if (num[i] < num[i - 1])
				swap(num[i], num[i - 1]);
		low++;
	}
}
/**********************************************************************************/
/*主函数*/
/**********************************************************************************/
int main()
{
	int num[MAX];
	input(num); //输入数组
	cout << "冒泡排序前：" << endl;
	output(num);
	sort(num, 1, MAX - 1);
	cout << "冒泡排序后：" << endl;
	output(num);
	return 0;
}
//方法三：
//快速排序
/*冒泡排序实现*/
/***********************************************************************************/
#include <iostream> 
#include <stdlib.h> 
#include <time.h> 
using namespace std;
#define MAX 11 
/***********************************************************************************/
/*输入函数*/
/***********************************************************************************/
void input(int num[])
{
	int i;

	srand((unsigned)time(NULL)); //设置随机种子
	for (i = 1; i < MAX; i++)
		num[i] = rand() % 100; //生成随机函数
}
/***********************************************************************************/
/*输出函数*/
/***********************************************************************************/
void output(int num[])
{
	int i;

	for (i = 1; i < MAX; i++)
	{
		cout << num[i] << " ";
		if (0 == i % 10)
			cout << endl;
	}
	cout << endl;
}
/************快速排序算法***********************/
template <class T>
void quickSort(T data[], int p, int r)
{
	int position = 0;
	if (p < r)
	{
		position = partition(data, p, r); //返回划界元素的最终位置
		quickSort(data, p, position - 1); //对划分的子序列进行递归操作
		quickSort(data, position + 1, r);
	}
}
/*************序列划分函数**********************/
template<class T> int partition(T data[], int p, int r)
{
	int position;
	T temp = data[r];
	int i = p - 1;
	for (int j = p; j < r; j++)
	{
		if (data[j] <= temp) //发现小于划界元素的键值时
		{ //交换元素 i+1 和元素 j 的值
			i += 1;
			exchange(&data[i], &data[j]);
		}
	}
	exchange(&data[i + 1], &data[r]);
	return i + 1;
}
/**************元素值交换函数*******************/
template <class T> void exchange(T* a, T* b)
{
	T temp = *a;
	*a = *b;
	*b = temp;
}
/**********************************************************************************/
/*主函数*/
/**********************************************************************************/
int main()
{
	int num[MAX];
	cout << "冒泡排序前：" << endl;
	input(num);
	output(num);
	quickSort(num, 0, 10);
	cout << "冒泡排序后：" << endl;
	output(num);
	return 0;
}